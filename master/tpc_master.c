/* FIXME Rename this to master.c */

#include <unistd.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/types.h>
#include <errno.h>
#include <stdbool.h>

#include "tpc.h" /* generated by rpcgen */
#include "vote.h"
#include "tpc_master.h"


int *results;
CLIENT **cl_arr;
char **args;

#define TEST_MASTER_DEATH 0

/* the index in the thread reaping loop at which master dies */
#define KILL_INDEX 1

int main(int argc, char *argv[])
{

    if (argc < 3) {
        printf("Usage: [-r repl_factor] -s slave_addr1 [... slave_addrn]\n");
        return 1;
    }

    /* TODO: separate the master functions into different files */

    // TODO Jahrme
    // if you decide to use message queue, try this 1-vec-at-a-time
    // message passing algorithm
    //
    // while (queue is empty)
    //  while (queue is not empty)
    //    pop message from queue
    //    2-phase commit agreement w/ slaves
    //    if all agree, make RPC calls w/ message args

    // FIXME: at this stage, parse out the command line arguments
    // using a function like getopt()


    /* connect to message queue */
    int msq_id = msgget(MSQ_KEY, MSQ_PERMISSIONS | IPC_CREAT);

    struct put_msgbuf *request;
    struct msqid_ds *buf;
    int rc; // ??

    while (true) {
        msgctl(msq_id, IPC_STAT, buf);
        if (buf->msg_qnum > 0) {
            
        }
    }


    return 0;
}
